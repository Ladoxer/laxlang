use crate::ast::*;
pub fn emit(p: &Program) -> String {
    let mut out = String::new();
    out.push_str("// generated by LaxLang\n");
    for stmt in &p.0 { match stmt {
        Stmt::Decl(Decl::RelaxFunc { name, .. }) =>
            out.push_str(&format!("function {}() {{ /* relax */ }}\n", name)),
        _ => {}
    }}
    out
}

if let Decl::RelaxFn(name, params, body) = d {
    w!("function {}(", name);
    join_params(params, &mut out, /*no types*/);
    w!(") {{\n");
    gen_block(body);
    w!("}}\n");
}

Expr::FlowChain(name, params, ops, handlers) => {
    w!("async function {}(", name); /* params with TS types */ …
    w!("try {{\n");
    indent();
    for op in ops {
        match op {
           FlowOp::Bind(expr, id) => {
               w!("const {} = await ", id); gen_expr(expr); w!(";\n");
           }
           FlowOp::Map(e1,e2) => {
               gen_expr(e1); w!(";\n");
               gen_expr(e2); w!(";\n");
           }
        }
    }
    dedent(); w!("}} catch (error) {{\n"); indent();
    for h in handlers { w!("if (error instanceof {}) return ", h.kind); gen_expr(&h.action); w!(";\n"); }
    w!("throw error;\n"); dedent(); w!("}}\n");
}

Match Guard::Sanitize => w!("app.use(xssClean());\n"),
Guard::RateLimit(n, d) => w!("app.use(rateLimit({ windowMs:{}, max:{} }));\n", parse_duration(d), n),
Guard::Authenticate => w!("app.use(requireAuth());\n"),

use_map.insert("express");
…

if use_map.contains("express") {
   w!("import express from 'express';\nimport cors from 'cors';\n");
}
